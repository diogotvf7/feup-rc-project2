\documentclass[11pt,a4paper,twocolumn]{article}

% --------------------------------Packages
\usepackage[margin=.75in]{geometry}
\usepackage{indentfirst}
\usepackage{titling}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{float}
\usepackage{hyperref}
\usepackage{listings}

% -----------------------Images path setup
\graphicspath{{./images/}}

% -----------------------Code blocks setup 
\lstnewenvironment{c-darktheme}{
    \lstset{
        language=C,                        % choose the language of the code
        backgroundcolor=\color{cb-background},
        basicstyle=\footnotesize\ttfamily\color{cb-foreground},
        keywordstyle=\color{cb-keyword}\bfseries,
        commentstyle=\color{cb-comment},
        stringstyle=\color{cb-string},
        numberstyle=\color{cb-number},
        emphstyle=\color{cb-preprocessor},
        keywordstyle=\bfseries,
        numbers=left,                      % where to put the line-numbers
        numberstyle=\scriptsize\texttt,    % the size of the fonts that are used for the line-numbers
        stepnumber=1,                      % the step between two line-numbers. If it's 1 each line will be numbered
        numbersep=8pt,                     % how far the line-numbers are from the code
        float=htb,
        aboveskip=3mm,
        belowskip=3mm,
        showspaces=false,                  % show spaces adding particular underscores
        showstringspaces=false,            % underline spaces within strings
        showtabs=false,                    % show tabs within strings adding particular underscores
        tabsize=2,                         % sets default tabsize to 2 spaces
        captionpos=b,                      % sets the caption-position to bottom
        breaklines=true,                   % sets automatic line breaking
        breakatwhitespace=false,           % sets if automatic breaks should only happen at whitespace
        escapeinside={\%*}{*)},            % if you want to add a comment within your code
        morekeywords={*,var,template,new}  % if you want to add more keywords to the set
        moretypes={}                       % if you want to add more types to the set
    }
}{}

\lstnewenvironment{bash-darktheme}{
    \lstset{
        language=bash,
        aboveskip=3mm,
        belowskip=3mm,
        showstringspaces=false,
        backgroundcolor=\color{cb-background},
        basicstyle=\footnotesize\ttfamily\color{cb-foreground},
        keywordstyle=\color{cb-keyword},
        commentstyle=\color{cb-comment},
        stringstyle=\color{cb-string},
        breaklines=true,
    }
}{}

% ---------------------------Custom colors 
\definecolor{text-hl1}{RGB}{190, 100, 10}
\definecolor{text-hl2}{RGB}{0, 128, 128}
\definecolor{link}{RGB}{50, 90, 150}

% ----------------------c-darktheme colors
\definecolor{cb-background}{HTML}{1E1E1E}
\definecolor{cb-foreground}{HTML}{D4D4D4}
\definecolor{cb-comment}{HTML}{6A9955}
\definecolor{cb-keyword}{HTML}{569cd6}
\definecolor{cb-string}{HTML}{ce9178}
\definecolor{cb-number}{HTML}{b5cea8}
\definecolor{cb-preprocessor}{HTML}{569cd6}

% -----------------------------Links setup 
\hypersetup{
    colorlinks=true,
    linkcolor=link,
    filecolor=magenta,
    urlcolor=cyan,
}

% -------------------------Custom commands 
\newcommand{\hl}[2][1]{%
  \ifnum#1=1\relax
    \textcolor{text-hl1}{#2}%
  \else
    \textcolor{text-hl2}{#2}% Default to text-hl2
  \fi
}

%%========================================
%% Start of document
%%========================================

% \makeindex

\title{%
  Redes de computadores \\
  \large 2º trabalho prático}
\author{%
        Diogo Fernandes (202108752) \\ 
        José Sereno (202108729)}
\def\course{Licenciatura em Engenharia Informática e Computação}
\date{Dezembro 2023}

\begin{document}

% -----------------------------------Title page
\begin{titlepage}
    \begin{center}
        \includegraphics[width=0.8\linewidth]{images/uporto-feup.pdf} 
        \vspace{1cm}

        \LARGE
        \textbf{\thetitle}
        \vfill

        \large
        \textbf{\course}
        \vspace{0.5cm}

        \large
        \textbf{\theauthor}
        \vspace{0.5cm}

        \large
        \thedate
    \end{center}
\end{titlepage}
% ---------------------------------------------

\tableofcontents

\section{Introdução}

\paragraph{Objetivos}
Este projeto teve dois objetivos:
\begin{enumerate}
    \item Desenvolver uma aplicação em \hl{C} que impletmente o protocolo \hl{FTP} - descrito no \href{https://datatracker.ietf.org/doc/html/rfc959}{RFC959} - para fazer o download de um ficheiro através de um \hl{URL} - a sintaxe deste URL deveria seguir o \href{https://datatracker.ietf.org/doc/html/rfc1738}{RFC1738}.
    \item Configurar e analisar o funcionamento de uma rede de computadores.
\end{enumerate}


\section{Desenvolvimento da aplicação}

O programa \hl{download} foi desenvolvido em \hl{C} e tem como objetivo fazer o download de um ficheiro através de um \hl{URL} que segue a sintaxe do \href{https://datatracker.ietf.org/doc/html/rfc1738}{RFC1738}.
Através da realização deste programa aprofundamos os nossos conhecimentos sobre os seguintes temas:
\begin{description}
    \item[Client-Server \& TCP/IP] Aprendemos como se dá a comunicação entre um cliente e um servidor através do protocolo \hl{TCP/IP}.
    \item[RFCs] RFCs são documentos que descrevem os padrões da internet. Consultámos, como referido anteriormente, o \href{https://datatracker.ietf.org/doc/html/rfc959}{RFC959} e o \href{https://datatracker.ietf.org/doc/html/rfc1738}{RFC1738}, para além de outras documentações, para entender o funcionamento do protocolo \hl{FTP} e da sintaxe do \hl{URL}.
    \item[Sockets] Aprendemos a usar \hl{sockets} em \hl{C} como forma de comunicação entre o cliente e o servidor.
    \item[DNS (Domain Name System)] Procurámos entender o funcionamento do \hl{DNS} e como é que este é usado para traduzir um \hl{URL} num endereço \hl{IP}.
    \item[UNIX] Aprendemos alguns comandos de \hl{UNIX} que usamos no nosso programa (ex.: \hl[2]{getaddrinfo}, \hl[2]{socket}, \hl[2]{connect}, \hl[2]{recv}, \hl[2]{send})
\end{description}

\subsection{Estrutura do código}

O código do programa \hl{download} está dividido em 3 ficheiros: \hl{download.c}, \hl{server.c} e \hl{url.h}.
É no ficheiro \hl{download.c} onde se encontra a função \hl{main} - onde se percebe o fluxo do programa. O ficheiro \hl{server.c} contém as funções que implementam o protocolo \hl{FTP} e o ficheiro \hl{url.h} contém as funções que permitem fazer o \hl{parse} do \hl{URL}.
O programa \hl{download} é compilado através do comando \hl{make} e é executado da seguinte forma:

\subsection{Fluxo do programa}

O programa é executado do seguinte comando:

\begin{bash-darktheme}
./download ftp://[<user>:<password>@]<host>/<url-path>
\end{bash-darktheme}

O fluxo do programa será o seguinte:

\begin{enumerate}
    \item \hl{Parse} do \hl{URL} para obter os seguintes campos: \hl[2]{user} (opcional), \hl[2]{password} (opcional), \hl[2]{host}, \hl[2]{port} (opcional, é usado o valor 21 por default no protocolo FTP) e \hl[2]{url-path}.
    \item Criação de uma \hl{socket} que, através de uma ligação TCP/IP, inicia uma conexão com o \hl[2]{host} na porta \hl[2]{port}.
    \item Envio dos comandos \hl{USER} e \hl{PASS} para o servidor juntos dos valores \hl[2]{user} e \hl[2]{password}, respetivamente. Caso estes valores não tenham sido especificados, usa-se o valor \hl{anonymous}.
    \item Envio do comando \hl{PASV} para o servidor para que este abra uma porta à qual nos conectaremos para futuramente recebermos o ficheiro.
    \item Criação de uma nova \hl{socket} que, através de uma ligação TCP/IP, inicia uma conexão com a nova porta aberta pelo servidor.
    \item Envio do comando \hl{RETR} através da porta inicial para o servidor junto do valor \hl[2]{url-path} para que o servidor nos envie o recurso especificado.
    \item Leitura do ficheiro através da \hl{socket} criada no ponto 5 e escrita do mesmo para um ficheiro local.
    \item Fecho das \hl{sockets} criadas.
\end{enumerate}

O \hl{parse} do \hl{URL} é feito a partir da função \hl[2]{parse\_url} que recebe uma \hl[2]{string} e devolve uma \hl[2]{struct} \hl{URL} com os campos especificados no ponto 1. Esta função usa uma máquina de estados e expressões regulares. \\
Todo o processo de comunicação entre o cliente e o servidor é feito através de \hl{sockets} e o protocolo usado é o \hl{TCP/IP}. A criação das \hl{sockets} é feita através da função \hl[2]{getaddrinfo} que recebe o \hl[2]{hostname} e a \hl[2]{porta} e devolve uma \hl[2]{struct} \hl{addrinfo} com os campos necessários para a criação da \hl{socket}. \\
As \hl[2]{sockets} são criadas através da função \hl{socket} e são feitas as respetivas ligações através da função \hl[2]{connect}. \\  
O envio de comandos pelas \hl[2]{sockets} é feito através da função \hl[2]{send} e a leitura das respostas do servidor é feita através da função \hl[2]{recv}. \\
Antes de ser enviado qualquer comando para o servidor, primeiro é feita a leitura do código de status do servidor através da função \hl[2]{recv}, de modo a termos uma noção do estado do servidor. \\
A escrita do ficheiro no disco é feita através da função \hl[2]{write}. \\

\section{Configurar e analisar o funcionamento de uma rede}

O objetivo deste conjunto de experiências é configurar uma rede de computadores de modo a que estes tenham acesso à internet para instalar ficheiros a partir de um servidor remoto usando o protocolo FTP desenvolvido ou seja, a aplicação.

\subsection{Experiência 1}

\subsubsection{Arquitetura da rede}
    
No fim desta experiência, a configuração da rede deverá consistir em 2 computadores (TUX63 e TUX64) conectados pelo Switch.

\subsubsection{Objetivo}

O propósito desta experiência foi a configuração de dois computadores na mesma rede de modo a permiti-los comunicar.

\subsubsection{Quais são os comandos necessários para esta experiência?}

\begin{bash-darktheme}
    # TUX63:
    ifconfig eth0 up
    ifconfig eth0 172.16.60.1/24

    # TUX64:
    ifconfig eth0 up
    ifconfig eth0 172.16.60.254/24
\end{bash-darktheme}
 
Estando conectados ao mesmo \hl{Switch}, os computadores comunicam entre sí usando a bridge default. Podemos testar a comunicação entre os dois computadores usando o comando \hl{ping} passando o endereço IP do outro computador como argumento: 

\begin{bash-darktheme}
    ping 172.16.60.254 # No TUX63
\end{bash-darktheme}

\subsubsection{O que são pacotes ARP e para que são usados?}

ARP (\hl{Address Resolution Protocol}) é um protocolo que traduz endereços IPv4 em endereços MAC numa LAN (Local Area Network). Esta tradução é importante porque apesar de os IPs serem usados para identificar os computadores numa rede, podem mudar ao longo do tempo e devido ao ambiente. Já os MACs são usados para identificar o hardware de um computador e são únicos e imutáveis. \\
Numa situação em que um \hl[2]{computador 1} quer enviar uma mensagem para um \hl[2]{computador 2}, este começa por verificar se o endereço IP do computador 2 está na sua cache de vizinhos de rede. Caso contrário, o \hl[2]{computador 1} terá de fazer uma tradução do endereço IP do \hl[2]{computador 2} para o seu endereço MAC. Para fazer esta tradução, o ARP fará um broadcast - envia para todos os computadores da rede - de um pedido ARP que apenas será respondido pelo \hl[2]{computador 2}. O \hl[2]{computador 2} responde ao pedido ARP com o seu endereço MAC e o \hl[2]{computador 1} guarda-o na sua cache de vizinhos de rede. \\
O comando de \hl[2]{UNIX}: \hl{arp}; é usado para manipular ou exibir a cache de vizinhos de rede IPv4 do kernel.

\subsubsection{O que são os os endereços MAC e IP dos pacotes ARP e porquê?}

O MAC \hl{Media Access Control} é um endereço físico que identifica um dispositivo numa rede. É usado na data link layer para assegurar o endereço físico do computador - isto significa que está relacionado com o hardware. Os endereços MAC são únicos e não podem ser alterados. É composto por 6 bytes (48 bits) e é representado em hexadecimal.\\
O IP \hl{Internet Protocol} é um endereço lógico que identifica uma conexão entre um computador e uma rede. Pode mudar ao longo do tempo e devido ao ambiente. É usado na network layer para assegurar o endereço lógico do computador - isto significa que está relacionado com o software. Os endereços IP podem ser facilmente encontrados por terceiros, pois são transmitidos pela internet. É composto por 4 bytes (32 bits) e é representado em decimal.


\subsubsection{Que pacotes é que o comando ping gera?}

O comando \hl{ping} gera pacotes \hl{ARP} e pacotes \hl{ICMP}. ICMP (\hl{Internet Control Message Protocol}) é um protocolo da camada de rede que reporta erros e fornece outras informações relevantes para o processamento de pacotes IP. Neste contexto, o ICMP é usado pelo comando ping para testar uma conexão de rede IP.

\subsubsection{Quais são os MAC e IP dos pacotes ping?}

Ver o ponto \ref{sec:analise-logs}.

\subsubsection{Como determinar se um pacote é ARP, IP ou ICMP?}

É possível determinar se um frame Ethernet recebido é \hl{ARP}, \hl{IP}, \hl{ICMP} verificando a captura do \hl[2]{WireShark}, na coluna Portocol. O \hl[2]{WireShark} faz esta distinção através do campo Type do cabeçalho Ethernet. O valor 0x0800 indica que o pacote é IP ou ICMP já que este se encontra guardado no pacote do IPv4, o valor 0x0806 indica que o pacote é ARP. 

\subsubsection{Como determinar o tamanho de um pacote recebido?}

O tamanho de um pacote recebido pode ser determinado através da captura do WireShark, na coluna Length. Além disso, o tamanho dos pacotes IPv4 pode ser determinado a partir de 2 bytes que se encontram no pacote. Quanto aos pacotes ARP, estes possuem um tamanho fixo de 28 bytes.

\subsubsection{O que é a interface loopback e porque é que é importante?}

A interface \hl{loopback} é uma interface de rede virtual que permite que um computador comunique consigo mesmo. É importante pois permite testar a stack de protocolos \hl[2]{TCP/IP} sem a necessidade de uma rede física. Essencialmente, a interface loopback, muitas vezes identificada pelo endereço \hl[2]{IP 127.0.0.1}, cria um ambiente isolado no próprio dispositivo, onde os dados enviados são retornados para a sí.

\subsubsection{Análise dos logs}\label{sec:analise-logs}

Inicialmente, o TUX63 não sabe o endereço MAC do TUX64 e vice-versa. Assim, o TUX63 envia um pacote ARP para o \hl{broadcast} (MAC FF:FF:FF:FF:FF:FF) com o endereço IP do TUX64. O TUX64 recebe o pacote ARP vindo do \hl{broadcast}, que contém o IP do TUX63, e responde ao TUX63 de modo a indicar que guardou o seu endereço IP no pedido ARP, enviando o seu endereço MAC. O TUX63 ao receber este pacote, guarda o endereço MAC do TUX64 na sua tabela ARP. Permitindo assim obter um PING request e PING response.
Os endereços IP e Mac obtidos são os seguintes:

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
    \hl{PC} & \hl{IP} & \hl{MAC} \\ \hline
    TUX63 & 172.16.60.1 & 00:21:5a:5a:75:bb  \\
    TUX64 & 172.16.60.254 & 00:21:5a:61:2d:df \\
    \end{tabular}
\end{table}

\subsection{Experiência 2}

\subsubsection{Arquitetura da rede}

No final da experiência, a configuração da rede deverá consistir em 2 computadores (\hl[2]{TUX63 e TUX64}) conectados à bridge (\hl[2]{bridge0}) e um computador (\hl[2]{TUX62}) conectado à bridge (\hl[2]{bridge1}). 

\subsubsection{Objetivo}

Esta experiência teve como objetivo ensinar-nos a configurar 2 domínios de rede diferentes no mesmo switch e verificar que por defeito não ocorre comunicação entre estes domínios, sendo necessária a sua configuração.

\subsubsection{Quais são os comandos necessários para esta experiência?}

\begin{bash-darktheme}
    # Continuando a partir da experiencia anterior:

    # No tux2
    ifconfig eth0 up
    ifconfig eth0 172.16.61.1/24

    # Switch
    /system reset-configuration

    /interface bridge add name=bridge60
    /interface bridge add name=bridge61

    # No tux3, para a sua porta eth0 X, no tux4 para a sua porta eth0 Y e no tux2 para a sua porta eth0 Z:
    /interface bridge port remove [find interface=etherX]
    /interface bridge port remove [find interface=etherY]
    /interface bridge port remove [find interface=etherZ]
    /interface bridge port add bridge=bridge60 interface=etherX
    /interface bridge port add bridge=bridge60 interface=etherY
    /interface bridge port add bridge=bridge61 interface=etherZ
\end{bash-darktheme}

\subsubsection{ Quantos domínios de broadcast existem? O que podemos concluir a partir dos logs? / Análise dos logs}

Como configuramos 2 bridges, podemos concluir que existem 2 domínios de broadcast. Isto porque cada bridge é um domínio de broadcast. Podemos concluir isto a partir dos logs pois o TUX3 obteve uma resposta do TUX4, mas não do TUX2. Isto significa que o TUX3 está no mesmo domínio de broadcast que o TUX4, mas não no mesmo domínio de broadcast que o TUX2.
Além disso, é possível concluir que passaram a existir 2 sub-redes, uma para cada bridge. Isto porque, apesar de ser possível fazer ping do TUX3 para o TUX4, não é possível fazer ping do TUX3 para o TUX2 já que, nos logs, não existem pacotes ICMP.

\subsection{Experiência 3}

\subsubsection{Arquitetura da rede}

No final desta experiência, é esperado que tenhamos uma arquitetura semelhante à da experiência anterior, com uma nova da conexão TUX64 à bridge (\hl{bridge61}) que mediará a comunicação entre as duas bridges.

\subsubsection{Objetivo}

O objetivo desta experiência foi ensinar-nos a transformar o TUX64 num router e a configurar o mesmo para que este possa comunicar com os restantes computadores e permitir que estes comuniquem entre sí.

\subsubsection{Quais são os comandos necessários para esta experiência?}

\begin{bash-darktheme}
        # Continuando a partir da experiencia anterior:

        # Switch - seja agora a conexao do eth1 do tux4 a bridge61 pela porta W

        /interface bridge port remove [find interface=etherW]
        /interface bridge port add bridge=bridge61 interface=etherW

        # No tux4
        ifconfig eth1 up
        ifconfig eth1 172.16.61.253/24

        sysctlnet.ipv4.ip_forward=1
        sysctlnet.ipv4.icmp_echo_ignore_broadcasts=0
        
        # No tux3
        route add -net 172.16.61.0/24 gw 172.16.60.254
        
        # No tux2
        route add -net 172.16.60.0/24 gw 172.16.61.253

\end{bash-darktheme}

Nota: Devido a não conseguirmos obter os logs na nossa bancada, foi necessário utilizar outros ips, mas o procedimento é o mesmo.

\subsubsection{Que rotas existem nos computadores? Qual o seu significado?}
    
Existem 2 rotas, no TUX62 e no TUX63. Como a rota 64 é um gateway de ambos, a rota 62 é para chegar ao 63 e a rota 63 é para chegar ao 62, passando pelo 64. 

\subsubsection{Que informação contém uma entrada da tabela de encaminhamento?}

Uma entrada da tabela de encaminhamento contém o endereço de destino/origem, o endereço de gateway e a máscara de rede.

\subsubsection{ Que mensagens ARP, e os endereços MAC, são observadas e porquê? / Análise dos logs} 


No caso do ping do TUX63 para o TUX62. As mensagens ARP trocadas contêm apenas os endereços MAC do TUX63 e do TUX64 e não do destino final (TUX62). Isto ocorre devido à existência da rota. O TUX63 não conhece o endereço do TUX62, apenas conhece o endereço do gateway (TUX64) que leva ao TUX62.

Quando se apaga as tabelas ARP no TUX64 e se corre o mesmo ping novamente, os 3 computadores não se conhecem, pois não sabem os endereços MAC uns dos outros. Ao realizar o ping, é lançado um pedido ARP para o \hl{broadcast} e para a sub-net da bridge60 a pedir o endereço MAC do TUX64, default gateway do TUX62. É gerada a resposta ARP e esta é enviada de volta para o TUX63, que guarda o endereço MAC do TUX64 na sua tabela ARP e vice-versa. 
De seguida, o ping passa pelo TUX64 e alcança o TUX62, sendo realizado o mesmo processo de troca de mensagens ARP entre o TUX64 e o TUX62.

É importante notar que o TUX63 não tem informação sobre o endereço MAC do TUX62 e vice-versa. Cada um destes computadores apenas conhece o endereço MAC do seu gateway, que é o TUX64.

\subsection{Experiência 4}

\subsubsection{Configuração de um Router Comercial e Implementação de NAT}

Nesta experiência foi-nos pedido que configurássemos um router comercial na nossa bridge (\hl{bridge61}).

\subsubsection{Quais são os comandos necessários para esta experiência?}

\begin{bash-darktheme}
    # Router Serial Console
    /interface bridge port remove [find interface=ether5]
    /interface bridge port add bridge=bridge61 interface=ether5
    /ip address add address=172.16.2.69/24 interface=ether1
    /ip address add address=172.16.61.254/24 interface=ether2
    /ip route add dst-address=172.16.60.0/24 gateway=172.16.61.253
    /ip route add dst-address=0.0.0.0/0 gateway=172.16.2.254 
    /ip firewall nat disable 0
    /ip firewall nat enable 0

    # Terminais dos TUXs
    route add default gw 172.16.61.254 # No tux62
    route add default gw 172.16.60.254 # No tux63
    route add default gw 172.16.61.254 # No tux64    
    sysctl net.ipv4.conf.eth0.accept_redirects=0 
    sysctl net.ipv4.conf.all.accept_redirects=0 
    route del -net 172.16.60.0 gw 172.16.61.253 netmask 255.255.255.0
    traceroute -n
    route add -net 172.16.60.0/24 gw 172.16.61.253
    sysctl net.ipv4.conf.eth0.accept_redirects=0 
    sysctl net.ipv4.conf.all.accept_redirects=0 

\end{bash-darktheme}

\subsubsection{Como configurar uma rota estática num router comercial?}

Para configurarmos uma rota estática no router comercial começamos por ligar o router ao \hl{TUX63} através de um cabo de série. De seguida, acedemos à consola de comandos do router através do \hl{GTKTerm} de modo a podermos configuar o router. Adicioná-mo-lo à bridge pretendida (\hl[2]{bridge61}) e atribuimos-lhe um IP na LAN. Temos também de lhe atribuir um IP para a rede exterior. Definimos também as rotas necessárias para chegar às redes da bridge (\hl[2]{bridge60}) e para chegar à internet, indicando os \hl{gateways} necessários.

\subsubsection{Quais são os caminhos seguidos pelos pacotes nas experiências, porquê?}\label{sec:exp4-caminhos}

Com os redirects desativados, os pacotes seguem o caminho TUX62 $\rightarrow$ TUX64 $\rightarrow$ TUX63. Isto acontece porque o TUX62 não sabe que o TUX64 é um router e, portanto, envia os pacotes para o TUX64. O TUX64, por sua vez, envia os pacotes para o TUX63, que é o destino final. \\
Com os redirects ativados, os pacotes seguem o caminho TUX62 $\rightarrow$ TUX63. Isto acontece porque o TUX62 sabe que o TUX64 é um router e, portanto, envia os pacotes diretamente para o TUX63.

\subsubsection{Como configurar o NAT num router comercial?}

Para configurar o NAT num router comercial, temos de aceder à consola de comandos do router através do \hl{GTKTerm} e executar os seguintes comandos:
\begin{bash-darktheme}
    /ip firewall nat disable 0
    /ip firewall nat enable 0
\end{bash-darktheme}

\subsubsection{O que faz o NAT?}

O NAT (\hl{Network Address Translation}) é um processo que permite que vários computadores partilhem um único endereço IP que é usado na comunicação com o exterior. O NAT é usado para traduzir endereços IP de uma \hl[2]{LAN} (i.e. privados) para endereços IP públicos.  
Este processo é muito importante uma vez que o número de endereços IPv4 públicos é limitado e, portanto, não é possível atribuir um endereço IPv4 público a cada dispositivo que se liga à internet.

\subsubsection{Análise dos logs}

Desenvolvendo o tópico abordado em \ref{sec:exp4-caminhos}, ao enivarmos um \hl{ping} do \hl[2]{TUX62} para o \hl[2]{TUX63} enquanto temos os redirects desativados, e após ter sido apagada a rota do \hl{TUX62} para a rede \hl{172.16.60.0/24} através do \hl{TUX64}, verificamos que o \hl{TUX62} envia o \hl{ping} para o \hl[2]{router} pela default route que definimos até conseguir chegar ao \hl{TUX63}.
Já quando ativamos os redirects, o \hl{TUX62} envia o \hl{ping} para o \hl{TUX64} e este reencaminha-o para o \hl{TUX63}. Isto acontece pois a ligação mais direta da rede passou a ser através do \hl{TUX64} e não o router. O \hl{TUX63} responde ao \hl{TUX64} e este reencaminha a resposta para o \hl{TUX62}. 

\subsection{Experiência 5}

\subsubsection{Arquitetura da rede}

A arquitetura desta experiência é a mesma da experiência anterior.

\subsubsection{Objetivo}

O objetivo desta experiência foi ensinar-nos a dar ping a hosts com a utilização do DNS.

\subsubsection{Quais são os comandos necessários para esta experiência?}

\begin{bash-darktheme}
    # Continuando a experiencia anterior:

    # No tux2
    echo 'nameserver 172.16.2.1' > /etc/resolv.conf
    
    # No tux3
    echo 'nameserver 172.16.2.1' > /etc/resolv.conf

\end{bash-darktheme}

\subsubsection{ Como configurar o DNS num host?}

No terminal do TUX2 e do TUX3, precisamos de correr o comando hl{sudo nano /etc/resolv.conf} e adicionar a seguinte linha:

\begin{bash-darktheme}
    nameserver <DNS IP address>
\end{bash-darktheme}

O \hl{DNS (Domain Name System)} mapeia um nome de um host/dominio para endereços de IP. Portanto, ao utilizar este comando, estamos a permitir dar pings a hosts e domínios.

\subsubsection{ Que pacotes são trocados pelo DNS e que informação é transportada?}

Os pacotes DNS  trocados são o DNS query e o DNS response. O DNS query contém o nome de domínio e o DNS response contém o endereço IP do nome de domínio. Tornando possível traduzir o nome de domínio num endereço IP no router.

\subsubsection{Análise dos logs}

Nesta experiência, a partir do TUX62, damos ping ao google.com. Como google.com não é um IP, é necessário utilizar o \hl{DNS}. 
Inicialmente, o DNS procura os nameservers que estão definidos no ficheiro \hl{/etc/resolv.conf}. De seguida, o DNS envia um pacote \hl{DNS query} para o nameserver. O nameserver responde com um pacote \hl{DNS response} que contém o endereço IP do google.com, permitindo com que o ping seja bem sucedido.

\subsection{Experiência 6}

\subsubsection{Objective} 

Nesta experiência devemos testar a aplicação que desenvolvemos na primeira parte do trabalho prático dentro da rede que configuramos nas experiências anteriores.

\subsubsection{Quantas conexões TCP são abertas pela aplicação FTP?}

A aplicação FTP abre duas conexões TCP. Uma para o controlo da aplicação e outra para a transferência de dados.

\subsubsection{Em que conexão é transportada a informação de controlo do FTP?}

A informação de controlo do FTP é transportada na primeira conexão TCP que é aberta pela aplicação.

\subsubsection{Quais são as fases de uma conexão TCP?}

As fases de uma conexão TCP são as seguintes:
\begin{description}
    \item[1. Estabelecimento de conexão] - O cliente envia um pacote \hl{SYN} para o servidor para iniciar uma conexão TCP. O servidor responde com um pacote \hl{SYN-ACK} para o cliente. O cliente responde com um pacote \hl{ACK} para o servidor.
    \item[2. Transferência de dados] - O cliente e o servidor trocam dados.
    \item[3. Encerramento da ligação] - O cliente envia um pacote \hl{FIN} para o servidor para terminar a conexão TCP. O servidor responde com um pacote \hl{ACK} para o cliente. Opcionalmente, o servidor também pode enviar um pacote \hl{FIN} para o cliente para terminar a conexão TCP ao qual o cliente responderá com um pacote \hl{ACK} para o servidor. 
\end{description}

\subsubsection{Como funciona o mecanismo ARQ TCP? Quais são os campos de TCP relevantes?}

O mecanismo ARQ (\hl{Automatic Repeat reQuest}) TCP é um mecanismo que permite que o protocolo TCP recupere pacotes perdidos. Este protocolo assegura que os pacotes são entregues ao destino sem erros e na ordem correta. Este mecanismo opera através de ACKs (\hl[2]{Acknowledgement}) e timeouts. Quando um pacote é enviado, o emissor espera por um ACK. Se o ACK não chegar dentro de um determinado período de tempo, o emissor reenvia o pacote.
Os campos de TCP que refletem este protocolo são os campos "Sequence Number" e "

\subsubsection{Como é que o mecanismo de controlo de congestão do TCP funciona? Como é que a taxa de transferência de dados evolui com o passar do tempo?}

O protocolo de controlo de congestão do TCP visa otimizar o desempenho da transferência de dados ao mesmo tempo que procura evitar a congestão da rede. A taxa de transferência de dados começa lenta e aumenta exponencialmente até que ocorra uma perda de pacotes. Quando uma perda de pacotes ocorre, a taxa de transferência de dados diminui e aumenta gradualmente até que ocorra uma nova perda de pacotes.

\subsubsection{A taxa de transferência de conexões de dados TCP é perturbada pelo aparecimento de uma segunda conexão TCP? Como?}





\section{Conclusão}

Com a realização completa e correta das experiências, como também da aplicação de download. Foi possível aprender mais sobre o funcionamento e configuração de uma rede como também e sobre os protocolos envolvidos na transferência dos dados, tanto ao longo da propagação pela network layer como na link layer.



\section{Anexos}


\subsection{Código}

\subsubsection{download.h}
\begin{c-darktheme}
    #ifndef DOWNLOAD_H
    #define DOWNLOAD_H

    #include <stdlib.h>
    #include <stdio.h>

    #include "url.h"
    #include "server.h"

    int download(const char *arg);

    #endif
\end{c-darktheme}

\subsubsection{server.h}
% ===================
\begin{c-darktheme}
    #ifndef UTIL_H
    #define UTIL_H
    
    #include <stdlib.h>
    #include <stdio.h>
    #include <string.h>
    #include <unistd.h>
    #include <netdb.h>
    #include <sys/types.h>
    #include <sys/socket.h>
    
    /**
     * https://man7.org/linux/man-pages/man3/getaddrinfo.3.html
     */
    
    // Server Status Codes
    #define SERVER_LOGIN_READY 220
    #define SERVER_PASSWORD_REQUIRED 331
    #define SERVER_LOGIN_SUCCESS 230
    #define SERVER_PASSIVE_READY 227
    #define FILE_STATUS_OKAY 150
    #define CLOSING_DATA_CONNECTION 226
    
    int get_status(int sfd);
    
    int get_connection(const char *hostname, const char *port);
    
    void auth(int sfd, const char *username, const char *password);
    
    void get_passive(int sfd, char *host, char *port);
    
    void request_file(int sfd, const char *filename);
    
    void get_file(int psfd, const char *filename);
    
    #endif
\end{c-darktheme}
% ===================

\subsubsection{url.h}
% ===================
\begin{c-darktheme}
    #ifndef URL_H
#define URL_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

enum url_read_state
{
    PROTOCOL,
    USER,
    HOST,
    PORT,
    PATH,
    END,
};

struct URL
{
    char protocol[16];
    char username[256];
    char password[256];
    char hostname[256];
    char ip[256];
    char port[16];
    char path[256];
};

struct URL parse_url(const char *arg);

void print_url(struct URL url);

const char *get_filename(const char *path);

#endif
\end{c-darktheme}
% ===================

\subsubsection{download.c}
% ===================
\begin{c-darktheme}
    #include "download.h"

    int download(const char *arg)
    {
        printf("----------------------------------------\n"); // PARSE URL
        struct URL url = parse_url(arg);
        print_url(url);
    
        printf("----------------------------------------\n"); // CONNECT TO SERVER
        int sfd = get_connection(url.hostname, url.port);
        printf("Connected to server (socket fd: %d)\n", sfd);
    
        printf("----------------------------------------\n"); // AUTHENTICATE
        auth(sfd, url.username, url.password);
        printf("Successfully authenticated as %s\n", url.username);
    
        printf("----------------------------------------\n"); // OPEN PASSIVE MODE
        char psv_hostname[INET6_ADDRSTRLEN], psv_port[6];
        get_passive(sfd, psv_hostname, psv_port);
        printf("Passive mode address: %s:%s\n", psv_hostname, psv_port);
    
        printf("----------------------------------------\n"); // CONNECT TO PASSIVE
        int psfd = get_connection(psv_hostname, psv_port);
        printf("Connected to passive (socket fd: %d)\n", psfd);
    
        printf("----------------------------------------\n"); // DOWNLOAD FILE
        const char *filename = get_filename(url.path);
        printf("Requesting file %s\n", url.path);
        request_file(sfd, url.path);
        printf("Starting download of %s\n", filename);
        get_file(psfd, filename);
    
        printf("----------------------------------------\n"); // CLOSE CONNECTIONS
        close(sfd);
        printf("Closed connection to server\n");
        close(psfd);
        printf("Closed connection to passive\n");
    
        return 0;
    }
    
\end{c-darktheme}
% ===================

\subsubsection{server.c}
% ===================
\begin{c-darktheme}
    #include "server.h"

// #include <arpa/inet.h>
// #include <netinet/in.h>

int get_status(int sfd)
{
    char buffer[1024];
    ssize_t total_bytes_read = 0;

    while (1)
    {
        usleep(100000);
        ssize_t bytes_read = recv(sfd, buffer, sizeof buffer - total_bytes_read, MSG_DONTWAIT);
        if (bytes_read < 0)
        {
            buffer[total_bytes_read] = '\0';
            break;
        }
        total_bytes_read += bytes_read;
    }

    int status;
    if (sscanf(buffer, "%d", &status) != 1)
    {
        fprintf(stderr, "Invalid status line: %s\n", buffer);
        exit(EXIT_FAILURE);
    }

    // printf("Full message:\n\"%s\"\n", buffer); // debug2
    // printf("Status: %d\n\n", status);          // debug2

    return status;
}

int get_connection(const char *hostname, const char *port)
{
    int sfd, s;
    struct addrinfo hints;
    struct addrinfo *result, *rp;
    // char ipstr[INET6_ADDRSTRLEN];

    memset(&hints, 0, sizeof hints);
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_protocol = IPPROTO_TCP;

    s = getaddrinfo(hostname, port, &hints, &result);
    if (s != 0)
    {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(s));
        exit(EXIT_FAILURE);
    }

    for (rp = result; rp != NULL; rp = rp->ai_next)
    {
        sfd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);

        if (sfd == -1)
            continue;

        if (connect(sfd, rp->ai_addr, rp->ai_addrlen) != -1)
            break;

        close(sfd);
    }

    // struct sockaddr_in *ipv4 = (struct sockaddr_in *)rp->ai_addr;
    // void *addr = &(ipv4->sin_addr);
    // inet_ntop(rp->ai_family, addr, ipstr, sizeof ipstr);
    // printf("Connected to %s:%s (%s)\n", hostname, port, ipstr);

    freeaddrinfo(result);

    if (rp == NULL)
    {
        fprintf(stderr, "Could not connect\n");
        exit(EXIT_FAILURE);
    }

    return sfd;
}

void auth(int sfd, const char *username, const char *password)
{
    char buf[266];
    int command_length;

    // printf("1 Step -------------- (check if service ready for new user) | =220\n"); // debug1
    if (get_status(sfd) != SERVER_LOGIN_READY)
    {
        fprintf(stderr, "Service not ready for new user.\n");
        exit(EXIT_FAILURE);
    }

    // printf("2 Step ------------------------------------- (sending user) | \n"); // debug1
    command_length = snprintf(buf, 266, "user %s\n", username);
    if (send(sfd, buf, command_length, 0) < 0)
    {
        fprintf(stderr, "Error sending username (%s).\n", username);
        exit(EXIT_FAILURE);
    }

    // printf("3 Step ------------------ (check if service needs password) | =331\n"); // debug1
    if (get_status(sfd) != SERVER_PASSWORD_REQUIRED)
    {
        fprintf(stderr, "Error, server should expect password\n");
        exit(EXIT_FAILURE);
    }

    // printf("4 Step -------------------------------- (send password) |\n"); // debug1
    command_length = snprintf(buf, 266, "pass %s\n", password);
    if (send(sfd, buf, command_length, 0) < 0)
    {
        fprintf(stderr, "Error sending password (%s).\n", password);
        exit(EXIT_FAILURE);
    }

    // printf("5 Step -------------------- (check if login was successful) | =230\n"); // debug1
    if (get_status(sfd) != SERVER_LOGIN_SUCCESS)
    {
        fprintf(stderr, "Login failed.\n");
        exit(EXIT_FAILURE);
    }
}

void get_passive(int sfd, char *host, char *port)
{
    char *in_buf = "pasv\n", out_buf[256];

    if (send(sfd, in_buf, strlen(in_buf), 0) < 0)
    {
        fprintf(stderr, "Error sending passive command.\n");
        exit(EXIT_FAILURE);
    }

    ssize_t bytes = recv(sfd, out_buf, sizeof out_buf - 1, 0);
    if (bytes < 0)
    {
        perror("recv");
        exit(EXIT_FAILURE);
    }
    out_buf[bytes] = '\0';

    int code;
    uint8_t h1, h2, h3, h4, p1, p2;
    sscanf(out_buf, "%d %*[^(](%hhu, %hhu, %hhu, %hhu, %hhu, %hhu)\n", &code, &h1, &h2, &h3, &h4, &p1, &p2);
    if (code != SERVER_PASSIVE_READY)
    {
        fprintf(stderr, "Error entering passive mode.\n");
        exit(EXIT_FAILURE);
    }

    sprintf(host, "%hhu.%hhu.%hhu.%hhu", h1, h2, h3, h4);
    sprintf(port, "%hu", p1 * 256 + p2);
}

void request_file(int sfd, const char *path)
{
    char buf[266];
    int command_length;

    command_length = snprintf(buf, 266, "retr %s\n", path);
    if (send(sfd, buf, command_length, 0) < 0)
    {
        fprintf(stderr, "Error sending file request (%s).\n", path);
        exit(EXIT_FAILURE);
    }

    int status = get_status(sfd);
    if (status == FILE_STATUS_OKAY || status == CLOSING_DATA_CONNECTION)
    {
        printf("File ok.\n");
        return;
    }
    else
    {
        fprintf(stderr, "File unavailable.\n");
        exit(EXIT_FAILURE);
    }
}

void get_file(int psfd, const char *filename)
{
    char output_path[256];
    strcpy(output_path, "output/");
    strcat(output_path, filename);

    FILE *fp = fopen(output_path, "w");
    if (fp == NULL)
    {
        fprintf(stderr, "Error opening file (%s).\n", filename);
        exit(EXIT_FAILURE);
    }

    char buf[256];
    ssize_t bytes;
    while ((bytes = recv(psfd, buf, sizeof buf - 1, 0)) > 0)
    {
        fwrite(buf, 1, bytes, fp);
    }

    fclose(fp);
}

\end{c-darktheme}
% ===================


\subsubsection{url.c}
% ===================
\begin{c-darktheme}
    #include "url.h"

struct URL parse_url(const char *arg)
{
    int state = PROTOCOL;
    struct URL url = {"", "", "", "", "", "", ""};

    while (state != END)
    {
        int n = 0;
        switch (state)
        {
        case PROTOCOL:
            // printf("PROTOCOL: %s\n", arg);
            if (sscanf(arg, "%15[^:@/]://%n", url.protocol, &n) && n > 0)
            {
                state = USER;
                arg += n;
            }
            else
            {
                // fprintf(stderr, "error: protocol not found for url: %s\n", arg);
                exit(EXIT_FAILURE);
            }
            break;
        case USER:
            // printf("USER: %s\n", arg);
            if (sscanf(arg, "%255[^:@/]:%255[^:@/]@%n", url.username, url.password, &n) && n > 0)
            {
                arg += n;
            }
            else if (sscanf(arg, "%255[^:@/]@%n", url.username, &n) && n > 0)
            {
                url.password[0] = '\0';
                arg += n;
            }
            else
            {
                url.username[0] = '\0';
                url.password[0] = '\0';
            }
            state = HOST;
            break;
        case HOST:
            // printf("HOST: %s\n", arg);
            if (sscanf(arg, "%255[^:/]:%n", url.hostname, &n) && n > 0)
            {
                state = PORT;
            }
            else if (sscanf(arg, "%255[^:/]/%n", url.hostname, &n) && n > 0)
            {
                state = PATH;
            }
            else if (sscanf(arg, "%255[^:/]%n", url.hostname, &n) && n > 0)
            {
                state = END;
            }
            else
            {
                // fprintf(stderr, "error: host not found for url: %s\n", arg);
                exit(EXIT_FAILURE);
            }
            arg += n;
            break;
        case PORT:
            // printf("PORT: %s\n", arg);
            if (sscanf(arg, "%5[0123456789]/%n", url.port, &n) && n > 0)
            {
                state = PATH;
            }
            else if (sscanf(arg, "%5[0123456789]%n", url.port, &n) && n > 0)
            {
                state = END;
            }
            else
            {
                // fprintf(stderr, "error: port not found for url: %s\n", arg);
                exit(EXIT_FAILURE);
            }
            arg += n;
            break;
        case PATH:
            // printf("PATH: %s\n", arg);
            if (sscanf(arg, "%255[^:@]%n", url.path, &n) == -1)
            {
                exit(EXIT_FAILURE);
            }
            arg += n;
            state = END;
            break;
        }
    }
    if (strlen(arg) > 0) // If there is something left in arg, it is an error
    {
        exit(EXIT_FAILURE);
    }
    if (strlen(url.username) == 0) // If username is empty, set it to anonymous
    {
        strcpy(url.username, "anonymous");
    }
    if (strlen(url.port) == 0) // If port is empty, set it to 21
    {
        strcpy(url.port, "21");
    }
    return url;
}

void print_url(struct URL url)
{
    printf("protocol: %s\n", url.protocol);
    printf("username: %s\n", url.username);
    printf("password: %s\n", url.password);
    printf("host: %s\n", url.hostname);
    printf("port: %s\n", url.port);
    printf("path: %s\n", url.path);
}

const char *get_filename(const char *path)
{
    const char *filename = strrchr(path, '/');
    if (filename == NULL)
    {
        return path;
    }
    else
    {
        return filename + 1;
    }
}

\end{c-darktheme}
% ===================

\subsubsection{main.c}
% ===================
\begin{c-darktheme}
    #include <stdio.h>
#include <stdlib.h>

#include "download.h"

int main(int argc, char *argv[])
{
    if (argc != 2)
    {
        printf("Usage: %s <url>\n", argv[0]);
        exit(1);
    }

    return download(argv[1]);
}
\end{c-darktheme}


\subsection{Wireshark}

\subsubsection{Experiência 1}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/part2-exp1.png}
    \caption{Experiência 1 - TUX64 <-> TUX 63}
\end{figure}

\subsubsection{Experiência 2}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/exp2-ping3-2.png}
    \caption{Experiência 2 - TUX63 -> TUX62}

\end{document}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/exp2-ping3-2-broadcast.png}
    \caption{Experiência 2 - TUX63 -> TUX62}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/exp2-ping3-3-broadcast.png}
    \caption{Experiência 2 - TUX63 -> TUX62}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/exp2-ping3-4-broadcast.png}
    \caption{Experiência 2 - TUX63 -> TUX64}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/exp2-ping2-3-broadcast.png}
    \caption{Experiência 2 - TUX62 -> TUX63}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/exp2-ping2-4-broadcast.png}
    \caption{Experiência 2 - TUX62 -> TUX64}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/exp2-ping2-2-broadcast.png}
    \caption{Experiência 2 - TUX62 -> TUX62}
\end{figure}

