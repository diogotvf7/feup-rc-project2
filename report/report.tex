\documentclass[11pt,a4paper,twocolumn]{article}

% --------------------------------Packages
\usepackage[margin=.75in]{geometry}
\usepackage{indentfirst}
\usepackage{titling}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{float}
\usepackage{hyperref}
\usepackage{listings}

% -----------------------Images path setup
\graphicspath{{./images/}}

% -----------------------Code blocks setup 
\lstnewenvironment{c-darktheme}{
    \lstset{
        language=C,                        % choose the language of the code
        backgroundcolor=\color{cb-background},
        basicstyle=\footnotesize\ttfamily\color{cb-foreground},
        keywordstyle=\color{cb-keyword}\bfseries,
        commentstyle=\color{cb-comment},
        stringstyle=\color{cb-string},
        numberstyle=\color{cb-number},
        emphstyle=\color{cb-preprocessor},
        keywordstyle=\bfseries,
        numbers=left,                      % where to put the line-numbers
        numberstyle=\scriptsize\texttt,    % the size of the fonts that are used for the line-numbers
        stepnumber=1,                      % the step between two line-numbers. If it's 1 each line will be numbered
        numbersep=8pt,                     % how far the line-numbers are from the code
        float=htb,
        aboveskip=3mm,
        belowskip=3mm,
        showspaces=false,                  % show spaces adding particular underscores
        showstringspaces=false,            % underline spaces within strings
        showtabs=false,                    % show tabs within strings adding particular underscores
        tabsize=2,                         % sets default tabsize to 2 spaces
        captionpos=b,                      % sets the caption-position to bottom
        breaklines=true,                   % sets automatic line breaking
        breakatwhitespace=false,           % sets if automatic breaks should only happen at whitespace
        escapeinside={\%*}{*)},            % if you want to add a comment within your code
        morekeywords={*,var,template,new}  % if you want to add more keywords to the set
        moretypes={}                       % if you want to add more types to the set
    }
}{}

\lstnewenvironment{bash-darktheme}{
    \lstset{
        language=bash,
        aboveskip=3mm,
        belowskip=3mm,
        showstringspaces=false,
        backgroundcolor=\color{cb-background},
        basicstyle=\footnotesize\ttfamily\color{cb-foreground},
        keywordstyle=\color{cb-keyword},
        commentstyle=\color{cb-comment},
        stringstyle=\color{cb-string},
        breaklines=true,
    }
}{}

% ---------------------------Custom colors 
\definecolor{text-hl1}{RGB}{190, 100, 10}
\definecolor{text-hl2}{RGB}{0, 128, 128}
\definecolor{link}{RGB}{50, 90, 150}

% ----------------------c-darktheme colors
\definecolor{cb-background}{HTML}{1E1E1E}
\definecolor{cb-foreground}{HTML}{D4D4D4}
\definecolor{cb-comment}{HTML}{6A9955}
\definecolor{cb-keyword}{HTML}{569cd6}
\definecolor{cb-string}{HTML}{ce9178}
\definecolor{cb-number}{HTML}{b5cea8}
\definecolor{cb-preprocessor}{HTML}{569cd6}

% -----------------------------Links setup 
\hypersetup{
    colorlinks=true,
    linkcolor=link,
    filecolor=magenta,
    urlcolor=cyan,
}

% -------------------------Custom commands 
\newcommand{\hl}[2][1]{%
  \ifnum#1=1\relax
    \textcolor{text-hl1}{#2}%
  \else
    \textcolor{text-hl2}{#2}% Default to text-hl2
  \fi
}

%%========================================
%% Start of document
%%========================================

% \makeindex

\title{%
  Redes de computadores \\
  \large 2º trabalho prático}
\author{%
        Diogo Fernandes (202108752) \\ 
        José Sereno (202108729)}
\def\course{Licenciatura em Engenharia Informática e Computação}
\date{Dezembro 2023}

\begin{document}

% -----------------------------------Title page
\begin{titlepage}
    \begin{center}
        \includegraphics[width=0.8\linewidth]{images/uporto-feup.pdf} 
        \vspace{1cm}

        \LARGE
        \textbf{\thetitle}
        \vfill

        \large
        \textbf{\course}
        \vspace{0.5cm}

        \large
        \textbf{\theauthor}
        \vspace{0.5cm}

        \large
        \thedate
    \end{center}
\end{titlepage}
% ---------------------------------------------

\tableofcontents

\section{Introdução}

\paragraph{Objetivos}
Este projeto teve dois objetivos:
\begin{enumerate}
    \item Desenvolver uma aplicação em \hl{C} que impletmente o protocolo \hl{FTP} - descrito no \href{https://datatracker.ietf.org/doc/html/rfc959}{RFC959} - para fazer o download de um ficheiro através de um \hl{URL} - a sintaxe deste URL deveria seguir o \href{https://datatracker.ietf.org/doc/html/rfc1738}{RFC1738}.
    \item Configurar e analisar o funcionamento de uma rede de computadores.
\end{enumerate}


\section{Desenvolvimento da aplicação}

O programa \hl{download} foi desenvolvido em \hl{C} e tem como objetivo fazer o download de um ficheiro através de um \hl{URL} que segue a sintaxe do \href{https://datatracker.ietf.org/doc/html/rfc1738}{RFC1738}.
Através da realização deste programa aprofundamos os nossos conhecimentos sobre os seguintes temas:
\begin{description}
    \item[Client-Server \& TCP/IP] Aprendemos como se dá a comunicação entre um cliente e um servidor através do protocolo \hl{TCP/IP}.
    \item[RFCs] RFCs são documentos que descrevem os padrões da internet. Consultámos, como referido anteriormente, o \href{https://datatracker.ietf.org/doc/html/rfc959}{RFC959} e o \href{https://datatracker.ietf.org/doc/html/rfc1738}{RFC1738}, para além de outras documentações, para entender o funcionamento do protocolo \hl{FTP} e da sintaxe do \hl{URL}.
    \item[Sockets] Aprendemos a usar \hl{sockets} em \hl{C} como forma de comunicação entre o cliente e o servidor.
    \item[DNS (Domain Name System)] Procurámos entender o funcionamento do \hl{DNS} e como é que este é usado para traduzir um \hl{URL} num endereço \hl{IP}.
    \item[UNIX] Aprendemos alguns comandos de \hl{UNIX} que usamos no nosso programa (ex.: \hl[2]{getaddrinfo}, \hl[2]{socket}, \hl[2]{connect}, \hl[2]{recv}, \hl[2]{send})
\end{description}

\subsection{Estrutura do código}

O código do programa \hl{download} está dividido em 3 ficheiros: \hl{download.c}, \hl{server.c} e \hl{url.h}.
É no ficheiro \hl{download.c} onde se encontra a função \hl{main} - onde se percebe o fluxo do programa. O ficheiro \hl{server.c} contém as funções que implementam o protocolo \hl{FTP} e o ficheiro \hl{url.h} contém as funções que permitem fazer o \hl{parse} do \hl{URL}.
O programa \hl{download} é compilado através do comando \hl{make} e é executado da seguinte forma:

\subsection{Fluxo do programa}

O programa é executado do seguinte comando:

\begin{bash-darktheme}
./download ftp://[<user>:<password>@]<host>/<url-path>
\end{bash-darktheme}

O fluxo do programa será o seguinte:

\begin{enumerate}
    \item \hl{Parse} do \hl{URL} para obter os seguintes campos: \hl[2]{user} (opcional), \hl[2]{password} (opcional), \hl[2]{host}, \hl[2]{port} (opcional, é usado o valor 21 por default no protocolo FTP) e \hl[2]{url-path}.
    \item Criação de uma \hl{socket} que, através de uma ligação TCP/IP, inicia uma conexão com o \hl[2]{host} na porta \hl[2]{port}.
    \item Envio dos comandos \hl{USER} e \hl{PASS} para o servidor juntos dos valores \hl[2]{user} e \hl[2]{password}, respetivamente. Caso estes valores não tenham sido especificados, usa-se o valor \hl{anonymous}.
    \item Envio do comando \hl{PASV} para o servidor para que este abra uma porta à qual nos conectaremos para futuramente recebermos o ficheiro.
    \item Criação de uma nova \hl{socket} que, através de uma ligação TCP/IP, inicia uma conexão com a nova porta aberta pelo servidor.
    \item Envio do comando \hl{RETR} através da porta inicial para o servidor junto do valor \hl[2]{url-path} para que o servidor nos envie o recurso especificado.
    \item Leitura do ficheiro através da \hl{socket} criada no ponto 5 e escrita do mesmo para um ficheiro local.
    \item Fecho das \hl{sockets} criadas.
\end{enumerate}

O \hl{parse} do \hl{URL} é feito a partir da função \hl[2]{parse\_url} que recebe uma \hl[2]{string} e devolve uma \hl[2]{struct} \hl{URL} com os campos especificados no ponto 1. Esta função usa uma máquina de estados e expressões regulares. \\
Todo o processo de comunicação entre o cliente e o servidor é feito através de \hl{sockets} e o protocolo usado é o \hl{TCP/IP}. A criação das \hl{sockets} é feita através da função \hl[2]{getaddrinfo} que recebe o \hl[2]{hostname} e a \hl[2]{porta} e devolve uma \hl[2]{struct} \hl{addrinfo} com os campos necessários para a criação da \hl{socket}. \\
As \hl[2]{sockets} são criadas através da função \hl{socket} e são feitas as respetivas ligações através da função \hl[2]{connect}. \\  
O envio de comandos pelas \hl[2]{sockets} é feito através da função \hl[2]{send} e a leitura das respostas do servidor é feita através da função \hl[2]{recv}. \\
Antes de ser enviado qualquer comando para o servidor, primeiro é feita a leitura do código de status do servidor através da função \hl[2]{recv}, de modo a termos uma noção do estado do servidor. \\
A escrita do ficheiro no disco é feita através da função \hl[2]{write}. \\

\section{Configurar e analisar o funcionamento de uma rede}

O objetivo deste conjunto de experiências é configurar uma rede de computadores de modo a que estes tenham acesso à internet para instalar ficheiros a partir de um servidor remoto usando o protocolo FTP desenvolvido ou seja, a aplicação.

\subsection{Experiência 1}

\subsubsection{Arquitetura da rede}
    
No fim desta experiência, a configuração da rede deverá consistir em 2 computadores (TUX63 e TUX64) conectados pelo Switch.

\subsubsection{Objetivo}

O propósito desta experiência foi a configuração de dois computadores na mesma rede de modo a permiti-los comunicar.

\subsubsection{Quais são os comandos necessários para esta experiência?}

\begin{bash-darktheme}
    # TUX63:
    ifconfig eth0 up
    ifconfig eth0 172.16.60.1/24

    # TUX64:
    ifconfig eth0 up
    ifconfig eth0 172.16.60.254/24
\end{bash-darktheme}
 
Estando conectados ao mesmo \hl{Switch}, os computadores comunicam entre sí usando a bridge default. Podemos testar a comunicação entre os dois computadores usando o comando \hl{ping} passando o endereço IP do outro computador como argumento: 

\begin{bash-darktheme}
    ping 172.16.60.254 # No TUX63
\end{bash-darktheme}

\subsubsection{O que são pacotes ARP e para que são usados?}

ARP (\hl{Address Resolution Protocol}) é um protocolo que traduz endereços IPv4 em endereços MAC numa LAN (Local Area Network). Esta tradução é importante porque apesar de os IPs serem usados para identificar os computadores numa rede, podem mudar ao longo do tempo e devido ao ambiente. Já os MACs são usados para identificar o hardware de um computador e são únicos e imutáveis. \\
Numa situação em que um \hl[2]{computador 1} quer enviar uma mensagem para um \hl[2]{computador 2}, este começa por verificar se o endereço IP do computador 2 está na sua cache de vizinhos de rede. Caso contrário, o \hl[2]{computador 1} terá de fazer uma tradução do endereço IP do \hl[2]{computador 2} para o seu endereço MAC. Para fazer esta tradução, o ARP fará um broadcast - envia para todos os computadores da rede - de um pedido ARP que apenas será respondido pelo \hl[2]{computador 2}. O \hl[2]{computador 2} responde ao pedido ARP com o seu endereço MAC e o \hl[2]{computador 1} guarda-o na sua cache de vizinhos de rede. \\
O comando de \hl[2]{UNIX}: \hl{arp}; é usado para manipular ou exibir a cache de vizinhos de rede IPv4 do kernel.

\subsubsection{O que são os os endereços MAC e IP dos pacotes ARP e porquê?}

O MAC \hl{Media Access Control} é um endereço físico que identifica um dispositivo numa rede. É usado na data link layer para assegurar o endereço físico do computador - isto significa que está relacionado com o hardware. Os endereços MAC são únicos e não podem ser alterados. É composto por 6 bytes (48 bits) e é representado em hexadecimal.\\
O IP \hl{Internet Protocol} é um endereço lógico que identifica uma conexão entre um computador e uma rede. Pode mudar ao longo do tempo e devido ao ambiente. É usado na network layer para assegurar o endereço lógico do computador - isto significa que está relacionado com o software. Os endereços IP podem ser facilmente encontrados por terceiros, pois são transmitidos pela internet. É composto por 4 bytes (32 bits) e é representado em decimal.


\subsubsection{Que pacotes é que o comando ping gera?}

O comando \hl{ping} gera pacotes \hl{ARP} e pacotes \hl{ICMP}. ICMP (\hl{Internet Control Message Protocol}) é um protocolo da camada de rede que reporta erros e fornece outras informações relevantes para o processamento de pacotes IP. Neste contexto, o ICMP é usado pelo comando ping para testar uma conexão de rede IP.

\subsubsection{Quais são os MAC e IP dos pacotes ping?}

Ver o ponto \ref{sec:analise-logs}.

\subsubsection{Como determinar se um pacote é ARP, IP ou ICMP?}

É possível determinar se um frame Ethernet recebido é \hl{ARP}, \hl{IP}, \hl{ICMP} verificando a captura do \hl[2]{WireShark}, na coluna Portocol. O \hl[2]{WireShark} faz esta distinção através do campo Type do cabeçalho Ethernet. O valor 0x0800 indica que o pacote é IP ou ICMP já que este se encontra guardado no pacote do IPv4, o valor 0x0806 indica que o pacote é ARP. 

\subsubsection{Como determinar o tamanho de um pacote recebido?}

O tamanho de um pacote recebido pode ser determinado através da captura do WireShark, na coluna Length. Além disso, o tamanho dos pacotes IPv4 pode ser determinado a partir de 2 bytes que se encontram no pacote. Quanto aos pacotes ARP, estes possuem um tamanho fixo de 28 bytes.

\subsubsection{O que é a interface loopback e porque é que é importante?}

A interface \hl{loopback} é uma interface de rede virtual que permite que um computador comunique consigo mesmo. É importante pois permite testar a stack de protocolos \hl[2]{TCP/IP} sem a necessidade de uma rede física. Essencialmente, a interface loopback, muitas vezes identificada pelo endereço \hl[2]{IP 127.0.0.1}, cria um ambiente isolado no próprio dispositivo, onde os dados enviados são retornados para a sí.

\subsubsection{Análise dos logs}\label{sec:analise-logs}

Inicialmente, o TUX63 não sabe o endereço MAC do TUX64 e vice-versa. Assim, o TUX63 envia um pacote ARP para o \hl{broadcast} (MAC FF:FF:FF:FF:FF:FF) com o endereço IP do TUX64. O TUX64 recebe o pacote ARP vindo do \hl{broadcast}, que contém o IP do TUX63, e responde ao TUX63 de modo a indicar que guardou o seu endereço IP no pedido ARP, enviando o seu endereço MAC. O TUX63 ao receber este pacote, guarda o endereço MAC do TUX64 na sua tabela ARP. Permitindo assim obter um PING request e PING response.
Os endereços IP e Mac obtidos são os seguintes:

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
    \hl{PC} & \hl{IP} & \hl{MAC} \\ \hline
    TUX63 & 172.16.60.1 & 00:21:5a:5a:75:bb  \\
    TUX64 & 172.16.60.254 & 00:21:5a:61:2d:df \\
    \end{tabular}
\end{table}

\subsection{Experiência 2}

\subsubsection{Arquitetura da rede}

No final da experiência, a configuração da rede deverá consistir em 2 computadores (\hl[2]{TUX63 e TUX64}) conectados à bridge (\hl[2]{bridge0}) e um computador (\hl[2]{TUX62}) conectado à bridge (\hl[2]{bridge1}). 

\subsubsection{Objetivo}

Esta experiência teve como objetivo ensinar-nos a configurar 2 domínios de rede diferentes no mesmo switch e verificar que por defeito não ocorre comunicação entre estes domínios, sendo necessária a sua configuração.

\subsubsection{Quais são os comandos necessários para esta experiência?}

\begin{bash-darktheme}
    # Continuando a partir da experiencia anterior:

    # No tux2
    ifconfig eth0 up
    ifconfig eth0 172.16.61.1/24

    # Switch
    /system reset-configuration

    /interface bridge add name=bridge60
    /interface bridge add name=bridge61

    # No tux3, para a sua porta eth0 X, no tux4 para a sua porta eth0 Y e no tux2 para a sua porta eth0 Z:
    /interface bridge port remove [find interface=etherX]
    /interface bridge port remove [find interface=etherY]
    /interface bridge port remove [find interface=etherZ]
    /interface bridge port add bridge=bridge60 interface=etherX
    /interface bridge port add bridge=bridge60 interface=etherY
    /interface bridge port add bridge=bridge61 interface=etherZ
\end{bash-darktheme}

\subsubsection{ Quantos domínios de broadcast existem? O que podemos concluir a partir dos logs? / Análise dos logs}

Como configuramos 2 bridges, podemos concluir que existem 2 domínios de broadcast. Isto porque cada bridge é um domínio de broadcast. Podemos concluir isto a partir dos logs pois o TUX3 obteve uma resposta do TUX4, mas não do TUX2. Isto significa que o TUX3 está no mesmo domínio de broadcast que o TUX4, mas não no mesmo domínio de broadcast que o TUX2.
Além disso, é possível concluir que passaram a existir 2 sub-redes, uma para cada bridge. Isto porque, apesar de ser possível fazer ping do TUX3 para o TUX4, não é possível fazer ping do TUX3 para o TUX2 já que, nos logs, não existem pacotes ICMP.

\subsection{Experiência 3}

\subsubsection{Arquitetura da rede}

No final desta experiência, é esperado que tenhamos uma arquitetura semelhante à da experiência anterior, com uma nova da conexão TUX64 à bridge (\hl{bridge61}) que mediará a comunicação entre as duas bridges.

\subsubsection{Objetivo}

O objetivo desta experiência foi ensinar-nos a transformar o TUX64 num router e a configurar o mesmo para que este possa comunicar com os restantes computadores e permitir que estes comuniquem entre sí.

\subsubsection{Quais são os comandos necessários para esta experiência?}

\begin{bash-darktheme}
        # Continuando a partir da experiencia anterior:

        # Switch - seja agora a conexao do eth1 do tux4 a bridge61 pela porta W

        /interface bridge port remove [find interface=etherW]
        /interface bridge port add bridge=bridge61 interface=etherW

        # No tux4
        ifconfig eth1 up
        ifconfig eth1 172.16.61.253/24

        sysctlnet.ipv4.ip_forward=1
        sysctlnet.ipv4.icmp_echo_ignore_broadcasts=0
        
        # No tux3
        route add -net 172.16.61.0/24 gw 172.16.60.254
        
        # No tux2
        route add -net 172.16.60.0/24 gw 172.16.61.253

\end{bash-darktheme}

Nota: Devido a não conseguirmos obter os logs na nossa bancada, foi necessário utilizar outros ips, mas o procedimento é o mesmo.

\subsubsection{Que rotas existem nos computadores? Qual o seu significado?}
    
Existem 2 rotas, no TUX62 e no TUX63. Como a rota 64 é um gateway de ambos, a rota 62 é para chegar ao 63 e a rota 63 é para chegar ao 62, passando pelo 64. 

\subsubsection{Que informação contém uma entrada da tabela de encaminhamento?}

Uma entrada da tabela de encaminhamento contém o endereço de destino/origem, o endereço de gateway e a máscara de rede.

\subsubsection{ Que mensagens ARP, e os endereços MAC, são observadas e porquê? / Análise dos logs} 


No caso do ping do TUX63 para o TUX62. As mensagens ARP trocadas contêm apenas os endereços MAC do TUX63 e do TUX64 e não do destino final (TUX62). Isto ocorre devido à existência da rota. O TUX63 não conhece o endereço do TUX62, apenas conhece o endereço do gateway (TUX64) que leva ao TUX62.

Quando se apaga as tabelas ARP no TUX64 e se corre o mesmo ping novamente, os 3 computadores não se conhecem, pois não sabem os endereços MAC uns dos outros. Ao realizar o ping, é lançado um pedido ARP para o \hl{broadcast} e para a sub-net da bridge60 a pedir o endereço MAC do TUX64, default gateway do TUX62. É gerada a resposta ARP e esta é enviada de volta para o TUX63, que guarda o endereço MAC do TUX64 na sua tabela ARP e vice-versa. 
De seguida, o ping passa pelo TUX64 e alcança o TUX62, sendo realizado o mesmo processo de troca de mensagens ARP entre o TUX64 e o TUX62.

É importante notar que o TUX63 não tem informação sobre o endereço MAC do TUX62 e vice-versa. Cada um destes computadores apenas conhece o endereço MAC do seu gateway, que é o TUX64.

\subsection{Experiência 4}

\subsubsection{Configuração de um Router Comercial e Implementação de NAT}

Nesta experiência foi-nos pedido que configurássemos um router comercial na nossa bridge (\hl{bridge61}).

\subsubsection{Quais são os comandos necessários para esta experiência?}

\begin{bash-darktheme}
    # Router Serial Console
    /interface bridge port remove [find interface=ether5]
    /interface bridge port add bridge=bridge61 interface=ether5
    /ip address add address=172.16.2.69/24 interface=ether1
    /ip address add address=172.16.61.254/24 interface=ether2
    /ip route add dst-address=172.16.60.0/24 gateway=172.16.61.253
    /ip route add dst-address=0.0.0.0/0 gateway=172.16.2.254 
    /ip firewall nat disable 0
    /ip firewall nat enable 0

    # Terminais dos TUXs
    route add default gw 172.16.61.254 # No tux62
    route add default gw 172.16.60.254 # No tux63
    route add default gw 172.16.61.254 # No tux64    
    sysctl net.ipv4.conf.eth0.accept_redirects=0 
    sysctl net.ipv4.conf.all.accept_redirects=0 
    route del -net 172.16.60.0 gw 172.16.61.253 netmask 255.255.255.0
    traceroute -n
    route add -net 172.16.60.0/24 gw 172.16.61.253
    sysctl net.ipv4.conf.eth0.accept_redirects=0 
    sysctl net.ipv4.conf.all.accept_redirects=0 

\end{bash-darktheme}

\subsubsection{Como configurar uma rota estática num router comercial?}

Para configurarmos uma rota estática no router comercial começamos por ligar o router ao \hl{TUX63} através de um cabo de série. De seguida, acedemos à consola de comandos do router através do \hl{GTKTerm} de modo a podermos configuar o router. Adicioná-mo-lo à bridge pretendida (\hl[2]{bridge61}) e atribuimos-lhe um IP na LAN. Temos também de lhe atribuir um IP para a rede exterior. Definimos também as rotas necessárias para chegar às redes da bridge (\hl[2]{bridge60}) e para chegar à internet, indicando os \hl{gateways} necessários.

\subsubsection{Quais são os caminhos seguidos pelos pacotes nas experiências, porquê?}\label{sec:exp4-caminhos}

Com os redirects desativados, os pacotes seguem o caminho TUX62 $\rightarrow$ TUX64 $\rightarrow$ TUX63. Isto acontece porque o TUX62 não sabe que o TUX64 é um router e, portanto, envia os pacotes para o TUX64. O TUX64, por sua vez, envia os pacotes para o TUX63, que é o destino final. \\
Com os redirects ativados, os pacotes seguem o caminho TUX62 $\rightarrow$ TUX63. Isto acontece porque o TUX62 sabe que o TUX64 é um router e, portanto, envia os pacotes diretamente para o TUX63.

\subsubsection{Como configurar o NAT num router comercial?}

Para configurar o NAT num router comercial, temos de aceder à consola de comandos do router através do \hl{GTKTerm} e executar os seguintes comandos:
\begin{bash-darktheme}
    /ip firewall nat disable 0
    /ip firewall nat enable 0
\end{bash-darktheme}

\subsubsection{O que faz o NAT?}

O NAT (\hl{Network Address Translation}) é um processo que permite que vários computadores partilhem um único endereço IP que é usado na comunicação com o exterior. O NAT é usado para traduzir endereços IP de uma \hl[2]{LAN} (i.e. privados) para endereços IP públicos.  
Este processo é muito importante uma vez que o número de endereços IPv4 públicos é limitado e, portanto, não é possível atribuir um endereço IPv4 público a cada dispositivo que se liga à internet.

\subsubsection{Análise dos logs}

Desenvolvendo o tópico abordado em \ref{sec:exp4-caminhos}, ao enivarmos um \hl{ping} do \hl[2]{TUX62} para o \hl[2]{TUX63} enquanto temos os redirects desativados, e após ter sido apagada a rota do \hl{TUX62} para a rede \hl{172.16.60.0/24} através do \hl{TUX64}, verificamos que o \hl{TUX62} envia o \hl{ping} para o \hl[2]{router} pela default route que definimos até conseguir chegar ao \hl{TUX63}.
Já quando ativamos os redirects, o \hl{TUX62} envia o \hl{ping} para o \hl{TUX64} e este reencaminha-o para o \hl{TUX63}. Isto acontece pois a ligação mais direta da rede passou a ser através do \hl{TUX64} e não o router. O \hl{TUX63} responde ao \hl{TUX64} e este reencaminha a resposta para o \hl{TUX62}. 

\subsection{Experiência 5}

\subsubsection{Arquitetura da rede}

A arquitetura desta experiência é a mesma da experiência anterior.

\subsubsection{Objetivo}

O objetivo desta experiência foi ensinar-nos a dar ping a hosts com a utilização do DNS.

\subsubsection{Quais são os comandos necessários para esta experiência?}

\begin{bash-darktheme}
    # Continuando a experiencia anterior:

    # No tux2
    echo 'nameserver 172.16.2.1' > /etc/resolv.conf
    
    # No tux3
    echo 'nameserver 172.16.2.1' > /etc/resolv.conf

\end{bash-darktheme}

\subsubsection{ Como configurar o DNS num host?}

No terminal do TUX2 e do TUX3, precisamos de correr o comando hl{sudo nano /etc/resolv.conf} e adicionar a seguinte linha:

\begin{bash-darktheme}
    nameserver <DNS IP address>
\end{bash-darktheme}

O \hl{DNS (Domain Name System)} mapeia um nome de um host/dominio para endereços de IP. Portanto, ao utilizar este comando, estamos a permitir dar pings a hosts e domínios.

\subsubsection{ Que pacotes são trocados pelo DNS e que informação é transportada?}

Os pacotes DNS  trocados são o DNS query e o DNS response. O DNS query contém o nome de domínio e o DNS response contém o endereço IP do nome de domínio. Tornando possível traduzir o nome de domínio num endereço IP no router.

\subsubsection{Análise dos logs}

Nesta experiência, a partir do TUX62, damos ping ao google.com. Como google.com não é um IP, é necessário utilizar o \hl{DNS}. 
Inicialmente, o DNS procura os nameservers que estão definidos no ficheiro \hl{/etc/resolv.conf}. De seguida, o DNS envia um pacote \hl{DNS query} para o nameserver. O nameserver responde com um pacote \hl{DNS response} que contém o endereço IP do google.com, permitindo com que o ping seja bem sucedido.

\subsection{Experiência 6}

\subsubsection{Objective} 

Nesta experiência devemos testar a aplicação que desenvolvemos na primeira parte do trabalho prático dentro da rede que configuramos nas experiências anteriores.

\subsubsection{Quantas conexões TCP são abertas pela aplicação FTP?}

A aplicação FTP abre duas conexões TCP. Uma para o controlo da aplicação e outra para a transferência de dados.

\subsubsection{Em que conexão é transportada a informação de controlo do FTP?}

A informação de controlo do FTP é transportada na primeira conexão TCP que é aberta pela aplicação.

\subsubsection{Quais são as fases de uma conexão TCP?}

As fases de uma conexão TCP são as seguintes:
\begin{description}
    \item[1. Estabelecimento de conexão] - O cliente envia um pacote \hl{SYN} para o servidor para iniciar uma conexão TCP. O servidor responde com um pacote \hl{SYN-ACK} para o cliente. O cliente responde com um pacote \hl{ACK} para o servidor.
    \item[2. Transferência de dados] - O cliente e o servidor trocam dados.
    \item[3. Encerramento da ligação] - O cliente envia um pacote \hl{FIN} para o servidor para terminar a conexão TCP. O servidor responde com um pacote \hl{ACK} para o cliente. Opcionalmente, o servidor também pode enviar um pacote \hl{FIN} para o cliente para terminar a conexão TCP ao qual o cliente responderá com um pacote \hl{ACK} para o servidor. 
\end{description}

\subsubsection{Como funciona o mecanismo ARQ TCP? Quais são os campos de TCP relevantes?}

O mecanismo ARQ (\hl{Automatic Repeat reQuest}) TCP é um mecanismo que permite que o protocolo TCP recupere pacotes perdidos. Este protocolo assegura que os pacotes são entregues ao destino sem erros e na ordem correta. Este mecanismo opera através de ACKs (\hl[2]{Acknowledgement}) e timeouts. Quando um pacote é enviado, o emissor espera por um ACK. Se o ACK não chegar dentro de um determinado período de tempo, o emissor reenvia o pacote.
O campo de TCP que reflete este protocolo é o campo "Sequence Number" que indica o número de sequência do pacote. Este campo é usado para ordenar os pacotes e para verificar se algum pacote foi perdido. 

\subsubsection{Como é que o mecanismo de controlo de congestão do TCP funciona? Como é que a taxa de transferência de dados evolui com o passar do tempo?}

O protocolo de controlo de congestão do TCP visa otimizar o desempenho da transferência de dados ao mesmo tempo que procura evitar a congestão da rede. A taxa de transferência de dados começa lenta e aumenta exponencialmente até que ocorra uma perda de pacotes. Quando uma perda de pacotes ocorre, a taxa de transferência de dados diminui e aumenta gradualmente até que ocorra uma nova perda de pacotes.

\subsubsection{A taxa de transferência em ligações de dados TCP é perturbada pelo aparecimento de uma segunda ligação TCP? Como?}

A taxa de transferência numa ligação de dados TCP é perturbada pelo aparecimento de uma segunda ligação uma vez que o protocolo TCP divide a sua largura de banda igualmente entre as ligações. 

\section{Conclusão}

Com a realização completa e correta das experiências, como também da aplicação de download. Foi possível aprender mais sobre o funcionamento e configuração de uma rede como também e sobre os protocolos envolvidos na transferência dos dados, tanto ao longo da propagação pela network layer como na link layer.

\section{Anexos}

\begin{c-darktheme}
    #ifndef DOWNLOAD_H
    #define DOWNLOAD_H

    #include <stdlib.h>
    #include <stdio.h>

    #include "url.h"
    #include "server.h"

    int download(const char *arg);

    #endif
\end{c-darktheme}

% ===================
\begin{c-darktheme}

\end{c-darktheme}
% ===================

% ===================
\begin{c-darktheme}

\end{c-darktheme}
% ===================

% ===================
\begin{c-darktheme}

\end{c-darktheme}
% ===================

% ===================
\begin{c-darktheme}

\end{c-darktheme}
% ===================

% ===================
\begin{c-darktheme}

\end{c-darktheme}
% ===================

% ===================
\begin{c-darktheme}

\end{c-darktheme}
% ===================

% ===================
\begin{c-darktheme}

\end{c-darktheme}
% ===================


\end{document}



