\documentclass[11pt,a4paper,twocolumn]{article}

% --------------------------------Packages
\usepackage[margin=.75in]{geometry}
\usepackage{indentfirst}
\usepackage{titling}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{float}
\usepackage{hyperref}
\usepackage{listings}

% -----------------------Images path setup
\graphicspath{{./images/}}

% -----------------------Code blocks setup 
\lstnewenvironment{c-darktheme}{
    \lstset{
        language=C,                        % choose the language of the code
        backgroundcolor=\color{cb-background},
        basicstyle=\footnotesize\ttfamily\color{cb-foreground}\fontfamily{Consolas},
        keywordstyle=\color{cb-keyword}\bfseries,
        commentstyle=\color{cb-comment},
        stringstyle=\color{cb-string},
        numberstyle=\color{cb-number},
        emphstyle=\color{cb-preprocessor},
        keywordstyle=\bfseries,
        numbers=left,                      % where to put the line-numbers
        numberstyle=\scriptsize\texttt,    % the size of the fonts that are used for the line-numbers
        stepnumber=1,                      % the step between two line-numbers. If it's 1 each line will be numbered
        numbersep=8pt,                     % how far the line-numbers are from the code
        float=htb,
        aboveskip=3mm,
        belowskip=3mm,
        showspaces=false,                  % show spaces adding particular underscores
        showstringspaces=false,            % underline spaces within strings
        showtabs=false,                    % show tabs within strings adding particular underscores
        tabsize=2,                         % sets default tabsize to 2 spaces
        captionpos=b,                      % sets the caption-position to bottom
        breaklines=true,                   % sets automatic line breaking
        breakatwhitespace=false,           % sets if automatic breaks should only happen at whitespace
        escapeinside={\%*}{*)},            % if you want to add a comment within your code
        morekeywords={*,var,template,new}  % if you want to add more keywords to the set
        moretypes={}                       % if you want to add more types to the set
    }
}{}

\lstnewenvironment{bash-darktheme}{
    \lstset{
        language=bash,
        aboveskip=3mm,
        belowskip=3mm,
        showstringspaces=false,
        backgroundcolor=\color{cb-background},
        basicstyle=\footnotesize\ttfamily\color{cb-foreground},
        keywordstyle=\color{cb-keyword},
        commentstyle=\color{cb-comment},
        stringstyle=\color{cb-string},
        breaklines=true,
    }
}{}

% ---------------------------Custom colors 
\definecolor{text-hl1}{RGB}{190, 100, 10}
\definecolor{text-hl2}{RGB}{0, 128, 128}
\definecolor{link}{RGB}{50, 90, 150}

% ----------------------c-darktheme colors
\definecolor{cb-background}{HTML}{1E1E1E}
\definecolor{cb-foreground}{HTML}{D4D4D4}
\definecolor{cb-comment}{HTML}{6A9955}
\definecolor{cb-keyword}{HTML}{569cd6}
\definecolor{cb-string}{HTML}{ce9178}
\definecolor{cb-number}{HTML}{b5cea8}
\definecolor{cb-preprocessor}{HTML}{569cd6}

% -----------------------------Links setup 
\hypersetup{
    colorlinks=true,
    linkcolor=link,
    filecolor=magenta,
    urlcolor=cyan,
}

% -------------------------Custom commands 
\newcommand{\hl}[2][1]{%
  \ifnum#1=1\relax
    \textcolor{text-hl1}{#2}%
  \else
    \textcolor{text-hl2}{#2}% Default to text-hl2
  \fi
}

%%========================================
%% Start of document
%%========================================

% \makeindex

\title{%
  Redes de computadores \\
  \large 2º trabalho prático}
\author{%
        Diogo Fernandes (202108752) \\ 
        José Sereno (202108729)}
\def\course{Licenciatura em Engenharia Informática e Computação}
\date{Dezembro 2023}

\begin{document}

% -----------------------------------Title page
\begin{titlepage}
    \begin{center}
        \includegraphics[width=0.8\linewidth]{images/uporto-feup.pdf} 
        \vspace{1cm}

        \LARGE
        \textbf{\thetitle}
        \vfill

        \large
        \textbf{\course}
        \vspace{0.5cm}

        \large
        \textbf{\theauthor}
        \vspace{0.5cm}

        \large
        \thedate
    \end{center}
\end{titlepage}
% ---------------------------------------------

\tableofcontents

\section{Introdução}

\paragraph{Objetivos}
Este projeto teve dois objetivos:
\begin{enumerate}
    \item Desenvolver uma aplicação em \hl{C} que impletmente o protocolo \hl{FTP} - descrito no \href{https://datatracker.ietf.org/doc/html/rfc959}{RFC959} - para fazer o download de um ficheiro através de um \hl{URL} - a sintaxe deste URL deveria seguir o \href{https://datatracker.ietf.org/doc/html/rfc1738}{RFC1738}.
    \item Configurar e analisar o funcionamento de uma rede de computadores.
\end{enumerate}


\section{Desenvolvimento da aplicação}

O programa \hl{download} foi desenvolvido em \hl{C} e tem como objetivo fazer o download de um ficheiro através de um \hl{URL} que segue a sintaxe do \href{https://datatracker.ietf.org/doc/html/rfc1738}{RFC1738}.
Através da realização deste programa aprofundamos os nossos conhecimentos sobre os seguintes temas:
\begin{description}
    \item[Client-Server \& TCP/IP] Aprendemos como se dá a comunicação entre um cliente e um servidor através do protocolo \hl{TCP/IP}.
    \item[RFCs] RFCs são documentos que descrevem os padrões da internet. Consultámos, como referido anteriormente, o \href{https://datatracker.ietf.org/doc/html/rfc959}{RFC959} e o \href{https://datatracker.ietf.org/doc/html/rfc1738}{RFC1738}, para além de outras documentações, para entender o funcionamento do protocolo \hl{FTP} e da sintaxe do \hl{URL}.
    \item[Sockets] Aprendemos a usar \hl{sockets} em \hl{C} como forma de comunicação entre o cliente e o servidor.
    \item[DNS (Domain Name System)] Procurámos entender o funcionamento do \hl{DNS} e como é que este é usado para traduzir um \hl{URL} num endereço \hl{IP}.
    \item[UNIX] Aprendemos alguns comandos de \hl{UNIX} que usamos no nosso programa (ex.: \hl[2]{getaddrinfo}, \hl[2]{socket}, \hl[2]{connect}, \hl[2]{recv}, \hl[2]{send})
\end{description}

\subsection{Estrutura do código}

O código do programa \hl{download} está dividido em 3 ficheiros: \hl{download.c}, \hl{server.c} e \hl{url.h}.
É no ficheiro \hl{download.c} onde se encontra a função \hl{main} - onde se percebe o fluxo do programa. O ficheiro \hl{server.c} contém as funções que implementam o protocolo \hl{FTP} e o ficheiro \hl{url.h} contém as funções que permitem fazer o \hl{parse} do \hl{URL}.
O programa \hl{download} é compilado através do comando \hl{make} e é executado da seguinte forma:

\subsection{Fluxo do programa}

O programa é executado do seguinte comando:

\begin{bash-darktheme}
./download ftp://[<user>:<password>@]<host>/<url-path>
\end{bash-darktheme}

O fluxo do programa será o seguinte:

\begin{enumerate}
    \item \hl{Parse} do \hl{URL} para obter os seguintes campos: \hl[2]{user} (opcional), \hl[2]{password} (opcional), \hl[2]{host}, \hl[2]{port} (opcional, é usado o valor 21 por default no protocolo FTP) e \hl[2]{url-path}.
    \item Criação de uma \hl{socket} que, através de uma ligação TCP/IP, inicia uma conexão com o \hl[2]{host} na porta \hl[2]{port}.
    \item Envio dos comandos \hl{USER} e \hl{PASS} para o servidor juntos dos valores \hl[2]{user} e \hl[2]{password}, respetivamente. Caso estes valores não tenham sido especificados, usa-se o valor \hl{anonymous}.
    \item Envio do comando \hl{PASV} para o servidor para que este abra uma porta à qual nos conectaremos para futuramente recebermos o ficheiro.
    \item Criação de uma nova \hl{socket} que, através de uma ligação TCP/IP, inicia uma conexão com a nova porta aberta pelo servidor.
    \item Envio do comando \hl{RETR} através da porta inicial para o servidor junto do valor \hl[2]{url-path} para que o servidor nos envie o recurso especificado.
    \item Leitura do ficheiro através da \hl{socket} criada no ponto 5 e escrita do mesmo para um ficheiro local.
    \item Fecho das \hl{sockets} criadas.
\end{enumerate}

O \hl{parse} do \hl{URL} é feito a partir da função \hl[2]{parse\_url} que recebe uma \hl[2]{string} e devolve uma \hl[2]{struct} \hl{URL} com os campos especificados no ponto 1. Esta função usa uma máquina de estados e expressões regulares. \\
Todo o processo de comunicação entre o cliente e o servidor é feito através de \hl{sockets} e o protocolo usado é o \hl{TCP/IP}. A criação das \hl{sockets} é feita através da função \hl[2]{getaddrinfo} que recebe o \hl[2]{hostname} e a \hl[2]{porta} e devolve uma \hl[2]{struct} \hl{addrinfo} com os campos necessários para a criação da \hl{socket}. \\
As \hl[2]{sockets} são criadas através da função \hl{socket} e são feitas as respetivas ligações através da função \hl[2]{connect}. \\  
O envio de comandos pelas \hl[2]{sockets} é feito através da função \hl[2]{send} e a leitura das respostas do servidor é feita através da função \hl[2]{recv}. \\
Antes de ser enviado qualquer comando para o servidor, primeiro é feita a leitura do código de status do servidor através da função \hl[2]{recv}, de modo a termos uma noção do estado do servidor. \\
A escrita do ficheiro no disco é feita através da função \hl[2]{write}. \\

\section{Configurar e analisar o funcionamento de uma rede}

O objetivo deste conjunto de experiências é configurar uma rede de computadores de modo a que estes tenham acesso à internet para instalar ficheiros a partir de um servidor remoto usando o protocolo FTP desenvolvido ou seja, a aplicação.

\subsection{Experiência 1}

\subsubsection{Arquitetura da rede}
    
No fim desta experiência, a configuração da rede deverá consistir de 2 computadores(TUX63 e TUX64) conectados pelo Switch.

\subsubsection{Objetivo}

O propósito desta experiência foi mostrar como fazer duas máquinas comunicar entre si através de uma rede.

\subsubsection{Quais são os comandos necessários para esta experiência?}

\begin{bash-darktheme}
    # TUX63:
    ifconfig eth0 up
    ifconfig eth0 172.16.60.1/24

    # TUX64:
    ifconfig eth0 up
    ifconfig eth0 172.16.60.254/24
\end{bash-darktheme}
 
Os computadores estavam connectados ao Switch, usando a bridge default deste para comunicarem entre si. 

Para testar a comunicação entre as duas máquinas, usamos o comando \hl{ping} no \hl{TUX63}: 

\begin{bash-darktheme}
    ping 172.16.60.254
\end{bash-darktheme}

\subsubsection{Quais são os pacotes ARP e para que são usados?}

ARP significa \hl{Address Resolution Protocol} e é um protocolo usado para encontrar o endereço MAC de um vizinho de rede para um determinado endereço IPv4. Este comando é usado para manipular ou exibir a cache de vizinhos de rede IPv4 do kernel.

\subsubsection{O que são os os endereços MAC e IP dos pacotes ARP e porquê?}

\hl{ARP} é um protocolo que associa endereços \hl{IP} a endereços \hl{MAC} na tabela ARP para permitir a utilização destes em uso futuro.
O MAC \hl{Media Access Control} é um endereço físico que identifica um dispositivo numa rede. É usado na data link layer para assegurar o endereço físico do computador - isto significa que está relacionado com o hardware. Os endereços MAC são únicos e não podem ser alterados. É composto por 6 bytes (48 bits) e é representado em hexadecimal.
O IP \hl{Internet Protocol} é um endereço lógico que identifica uma conexão entre um computador e uma rede. Pode mudar ao longo do tempo e devido ao ambiente. É usado na network layer para assegurar o endereço lógico do computador - isto significa que está relacionado com o software. Os endereços IP podem ser facilmente encontrados por terceiros, pois são transmitidos pela internet. É composto por 4 bytes (32 bits) e é representado em decimal.


\subsubsection{Que pacotes é que o comando ping gera?}

O comando \hl{ping} gera pacotes \hl{ARP} e pacotes \hl{ICMP}. ICMP \hl{Internet Control Message Protocol} é um protocolo da camada de rede que reporta erros e fornece outras informações relevantes para o processamento de pacotes IP. ICMP é usado pelo comando ping para testar uma conexão de rede IP.

\subsubsection{Quais são os MAC e IP dos pacotes ping?}

Encontram-se na secção de análise dos logs desta experiência. 

\subsubsection{Como determinar se um pacote é ARP, IP ou ICMP?}

É possível determinar se um frame Ethernet recebido é ARP, IP, ICMP verificando a captura do WireShark, na coluna Portocol. Também é possível verificar o tipo de pacote através do campo Type do cabeçalho Ethernet. O valor 0x0800 indica que o pacote é IP ou ICMP já que este se encontra guardado no pacote do IPv4, o valor 0x0806 indica que o pacote é ARP.

\subsubsection{Como determinar o tamanho de um pacote recebido?}

O tamanho de um pacote recebido pode ser determinado através da captura do WireShark, na coluna Length. Além disso, o tamanho dos pacotes IPv4 pode ser determinado a partir de 2 bytes que se encontram no pacote.
Quanto aos pacotes ARP, estes possuem um tamanho fixo de 28 bytes.

\subsubsection{O que é a interface loopback e porque é que é importante?}

A interface loopback é uma interface de rede virtual que permite que um computador se comunique consigo mesmo. É importante pois permite testar a pilha de protocolos TCP/IP sem a necessidade de uma rede física.

\subsubsection{Análise dos logs}

Inicialmente, o TUX63 não sabe o endereço MAC do TUX64 e vice-versa. Assim, o TUX63 envia um pacote ARP para o \hl{broadcast} (MAC FF:FF:FF:FF:FF:FF) com o endereço IP do TUX64. O TUX64 recebe o pacote ARP vindo do \hl{broadcast}, que contém o IP do TUX63, e responde ao TUX63 de modo a indicar que guardou o seu endereço IP no pedido ARP, enviando o seu endereço MAC. O TUX63 ao receber este pacote, guarda o endereço MAC do TUX64 na sua tabela ARP. Permitindo assim obter um PING request e PING response.
Os endereços IP e Mac obtidos são os seguintes:

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
    \hl{PC} & \hl{IP} & \hl{MAC} \\ \hline
    TUX63 & 172.16.60.1 & 00:21:5a:5a:75:bb  \\
    TUX64 & 172.16.60.254 & 00:21:5a:61:2d:df \\
    \end{tabular}
\end{table}

\subsection{Experiência 2}

\subsubsection{Arquitetura da rede}

No final da experiência, a configuração da red deverá consistir de 2 computadores (TUX63 e TUX64) e um computador (TUX62) conectados às bridges (bridge0) e (bridge1) pelo Switch, respetivamente. 

\subsubsection{Objetivo}

Esta experiência teve como objetivo ensinar-nos a configurar 2 domínios de rede diferentes no mesmo switch e verificar que por padrão não ocorre comunicação entre estes domínios.

\subsubsection{Quais são os comandos necessários para esta experiência?}

\begin{bash-darktheme}
    # Continuando a partir da experiencia anterior:

    # No tux2
    ifconfig eth0 up
    ifconfig eth0 172.16.61.1/24

    # Switch
    /system reset-configuration

    /interface bridge add name=bridge60
    /interface bridge add name=bridge61

    # No tux3, para a sua porta eth0 X, no tux4 para a sua porta eth0 Y e no tux2 para a sua porta eth0 Z:
    /interface bridge port remove [find interface=etherX]
    /interface bridge port remove [find interface=etherY]
    /interface bridge port remove [find interface=etherZ]
    /interface bridge port add bridge=bridge60 interface=etherX
    /interface bridge port add bridge=bridge60 interface=etherY
    /interface bridge port add bridge=bridge61 interface=etherZ
\end{bash-darktheme}

\subsubsection{ Quantos domínios de broadcast existem? O que podemos concluir a partir dos logs? / Análise dos logs}

Como configuramos 2 bridges, podemos concluir que existem 2 domínios de broadcast. Isto porque cada bridge é um domínio de broadcast. Podemos concluir isto a partir dos logs pois o TUX3 obteve uma resposta do TUX4, mas não do TUX2. Isto significa que o TUX3 está no mesmo domínio de broadcast que o TUX4, mas não no mesmo domínio de broadcast que o TUX2.
Além disso, é possível concluir que passaram a existir 2 sub-redes, uma para cada bridge. Isto porque, apesar de ser possível fazer ping do TUX3 para o TUX4, não é possível fazer ping do TUX3 para o TUX2 já que, nos logs, não existem pacotes ICMP.

\subsection{Experiência 3}

\subsubsection{Arquitetura da rede}

No final desta experiência, é esperado obtermos uma arquitetura semelhante à da experiência anterior, com a adição da conexão do TUX64 a ambas as bridges.

\subsubsection{Objetivo}

O objetivo desta experiência foi ensinar-nos a transformar o TUX64 num router e a configurar o mesmo para que este possa comunicar com os restantes computadores.

\subsubsection{Quais são os comandos necessários para esta experiência?}

\begin{bash-darktheme}
        # Continuando a partir da experiencia anterior:

        # Switch - seja agora a conexao do eth1 do tux4 a bridge61 pela porta W

        /interface bridge port remove [find interface=etherW]
        /interface bridge port add bridge=bridge61 interface=etherW

        # No tux4
        ifconfig eth1 up
        ifconfig eth1 172.16.61.253/24

        sysctlnet.ipv4.ip_forward=1
        sysctlnet.ipv4.icmp_echo_ignore_broadcasts=0
        
        # No tux3
        route add -net 172.16.61.0/24 gw 172.16.60.254
        
        # No tux2
        route add -net 172.16.60.0/24 gw 172.16.61.253

\end{bash-darktheme}

Nota: Devido a não conseguirmos obter os logs na nossa mesa, foi necessário utilizar outros ips, mas o procedimento é o mesmo.

\subsubsection{Que rotas existem nos computadores? Qual o seu significado?}
    
Existem 2 rotas, no TUX62 e no TUX63. Como a rota 64 é um gateway de ambos, a rota 62 é para chegar ao 63 e a rota 63 é para chegar ao 62, passando pelo 64. 

\subsubsection{Que informação contém uma entrada da tabela de encaminhamento?}

Uma entrada da tabela de encaminhamento contém o endereço de destino/origem, o endereço de gateway e a máscara de rede.

\subsubsection{ Que mensagens ARP, e os endereços MAC, são observadas e porquê? / Análise dos logs} 

The exchanged ARP messages contain only the MAC addresses of Tux63 and Tux64 and not the final destination(Tux62).
This occurs because of the existence of the route. 
Tux63 does not know the address of Tux62, it only knows the address of the gateaway (Tux64) that leads to Tux62.

No caso do ping do TUX63 para o TUX62. As mensagens ARP trocadas contêm apenas os endereços MAC do TUX63 e do TUX64 e não do destino final (TUX62). Isto ocorre devido à existência da rota. O TUX63 não conhece o endereço do TUX62, apenas conhece o endereço do gateway (TUX64) que leva ao TUX62.

Quando se apaga as tabelas ARP no TUX64 e se corre o mesmo ping novamente, os 3 computadores não se conhecem, pois não sabem os endereços MAC uns dos outros. Ao realizar o ping, é lançado um pedido ARP para o \hl{broadcast} e para a sub-net da bridge60 a pedir o endereço MAC do TUX64, default gateway do TUX62. É gerada a resposta ARP e esta é enviada de volta para o TUX63, que guarda o endereço MAC do TUX64 na sua tabela ARP e vice-versa. 
De seguida, o ping passa pelo TUX64 e alcança o TUX62, sendo realizado o mesmo processo de troca de mensagens ARP entre o TUX64 e o TUX62.

É importante notar que o TUX63 não tem informação sobre o endereço MAC do TUX62 e vice-versa. Cada um destes computadores apenas conhece o endereço MAC do seu gateway, que é o TUX64.


% ...


\subsection{Exp 4 - Configuração de um Router Comercial e Implementação de NAT}




\subsection{Experiência 5}

\subsubsection{Arquitetura da rede}

A arquitetura desta experiência é a mesma da experiência anterior.

\subsubsection{Objetivo}

O objetivo desta experiência foi ensinar-nos a dar ping a hosts com a utilização do DNS.

\subsubsection{Quais são os comandos necessários para esta experiência?}

\begin{bash-darktheme}
    # Continuando a experiencia anterior:

    # No tux2
    echo 'nameserver 172.16.2.1' > /etc/resolv.conf
    
    # No tux3
    echo 'nameserver 172.16.2.1' > /etc/resolv.conf

\end{bash-darktheme}

\subsubsection{ Como configurar o DNS num host?}

No terminal do TUX2 e do TUX3, precisamos de correr o comando hl{sudo nano /etc/resolv.conf} e adicionar a seguinte linha:

\begin{bash-darktheme}
    nameserver <DNS IP address>
\end{bash-darktheme}

O \hl{DNS (Domain Name System)} mapeia um nome de um host/dominio para endereços de IP. Portanto, ao utilizar este comando, estamos a permitir dar pings a hosts e domínios.

\subsubsection{ Que pacotes são trocados pelo DNS e que informação é transportada?}

Os pacotes DNS  trocados são o DNS query e o DNS response. O DNS query contém o nome de domínio e o DNS response contém o endereço IP do nome de domínio. Tornando possível traduzir o nome de domínio num endereço IP no router.

\subsubsection{Análise dos logs}

Nesta experiência, a partir do TUX62, damos ping ao google.com. Como google.com não é um IP, é necessário utilizar o \hl{DNS}. 
Inicialmente, o DNS procura os nameservers que estão definidos no ficheiro \hl{/etc/resolv.conf}. De seguida, o DNS envia um pacote \hl{DNS query} para o nameserver. O nameserver responde com um pacote \hl{DNS response} que contém o endereço IP do google.com, permitindo com que o ping seja bem sucedido.

\end{document}

